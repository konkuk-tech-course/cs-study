# CPU bound와 IO bound의 와 두 가지가 프로그램 Thread 개수 결정에 어떤 영향을 주는가
- CPU: 프로세스의 명령어를 해석하고 실행하는 장치
- IO: 파일을 읽고 쓰거나 네트워크의 어딘가와 데이터를 주고받는 것. 입출력장치와 데이터를 주고 받는 것.
- burst: 어떤 현상이 짧은 시간안에 집중적으로 일어나는 일
- CPU burst: 임의이 프로세스가 CPU안에서 한번에 연속적으로 실행되는 시간.
  - 메모리에 올라가 있는 프로세스가 자신의 차례까 되어 CPU에서 실행되었을 때, 자신의 명령어들이 CPU에서 연속적으로 실행되는 시간.
- IO burst: 프로세스가 IO 작업을 요청하고 결과를 기다리는 시간

프로세스의 인생은 CPU burst와 IO burst의 연속이다.

## CPU bound 프로세스와 IO bound 프로세스
- CPU bound process: CPU burst가 많은 프로세스 (I/O burst는 상대적으로 적은)
  - 예 ) 동영상 편집 프로그램, 머신러닝 프로그램 (연산작업이 많은 프로그램)
- IO bound process: IO burst가 많은 프로세스 
  - 예 ) (일반적인) 백엔드 API 서버: 보통 API서버들은 HTTP request를 받으면, DB 서버, Cache 서버에 데이터를 요청한다. 그리고 요청받아 적당한 형태로 가공 한뒤 HTTP 응답한다. 
    - 이때, DB/Cache 서버에 data 요청하는 작업이 IO 작업이다. 네트워크를 타기 때문에 CPU에서 명령어 몇개 처리 되는 것 보다 더 오래걸린다.

### 그럼 몇개의 스레드를 생성하는 것이 좋을까?
퀴즈) dual core CPU에서 동작하는 CPU bound 프로그램을 구현 할 때, 몇개의 스레드를 쓰는것이 좋은가?
- Goetz(2002, 2006)의 발표에 따르면, CPU bound program에서 적절한 스레드 수는 CPU 개수(코어 개수) + 1
  - Context Switching과 관련이 있음. context switching은 CPU를 잡아 먹는 overhead.
- 코어 개수 만큼 스레드 두는 것이 좋다. 혹은 거의 벗어나지 않는 수준에서 스레드를 만드는 것이 좋다.

### IO bound 프로그램은 몇개의 스레드 구현이 적절한가?
- 여러 상황에 맞춰 적절한 스레드 수를 찾아야 한다.
- 예를들어 만약 API 서버가 Thread per request 방식(API 요청이 있을때 마다 전담 Thread를 할당해 요청을 처리하는 방식)이라면?
  - **여러 상황을 고려해서 결정하는 것이 필요하다** (API 서버 하드웨어 스펙, API 서버에서 IO burst 비중이 어느정도인지, 예상되는 트래픽 패턴은 어떤지 등등..)
  - 바쁘면 감각에 기대어 대충 정해 투입하고 이후 모니터링하여 고치거나 실제 서비스 문제 터지고 수정하기도 하지만 좋은 방법은 아님.