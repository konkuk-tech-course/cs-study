# 네트워크 기술 면접 대비

**www.google.com을 url에 입력하면 어떤 일이 발생하는가?**

→ url을 바탕으로 먼저 request message를 작성한다

(구조: request line + request headers + blank line + request message body)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b244fb5-6426-411a-b8d2-d5a272d2c8d5/Untitled.png)

그리고 protocol stack(계층화된 프로토콜 집합)에 요청을 의뢰한다.

→ protocol stack은 소켓을 작성하고 서버와 연결하게 되는데 이때,

url 바탕으로 DNS 서버 검색 → IP 주소 검색

가장 가까운 DNS 서버에 찾는 URL에 대한 IP 없을 경우 root DNS 서버로 올라가 요청 → 타고 내려오면서 캐싱

그리고 DNS 서버로 부터 IP를 얻어와 MAC address를 찾는데, ARP 프로토콜을 통해서 서버의 MAC 주소를 얻어온다.

소켓에는 포트 번호가 있는데, 이를 통해서 서버로 라우터를 통해 전송하게 된다.

해당 서버에 도착하면 3-way-handshake가 발생하여 연결을 맺고, 응답을 받은 후 4-way-handshake로 요청을 끊는다.

그리고 일정 시간이 지난 후 socket이 말소 되고, 응답이 client에 도착하면 html, css에 맞게 화면이 보여지게 된다.

**HTTP의 GET / POST 비교**

Http 메서드의 종류이다.

**GET 방식** : 요청하는 데이터가 `http request message`의 헤더 부분에 url이 담겨 전송된다.

때문에 url 상에 ? 뒤 쿼리파라미터로 값 전달

→ 데이터 크기 제한적 / 보안이 필요한 데이터 경우 url 노출되므로 적절하지 않음

(HTTPS 는 body만 암호화한다)

- 데이터 조회시 사용 (REST API)
- 멱등성 보장

**POST 방식 :**   `http request message`의 body 부분에 데이터가 담겨서 전송된다.

따라서 바이너리 데이터 요청시 post 방식으로 보내야 한다.

- 데이터 크기가 상대적으로 큼 / 보안적인 측면에서 https에 의해 암호화 됨.
- 서버 값 또는 상태 변경하기 위해서 OR 추가하기 위해서 사용(REST API)
- 멱등성 보장 X (PATCH와 함께)

※ 멱등성 : 여러번 동일한 연산을 적용하더라도 서버의 상태가 동일한 응답을 나타내는 것

**3-WAY-HANDSHAKE**

1. SYN(Synchronization) 단계
- client는 server에 클라이언트의 **ISN(Initial Sequence Number)**을 담아 SYN을 보낸다.
- ISN은 새로운 **TCP 연결의 첫번째 패킷에 할당된 임의의 시퀀스 번호**를 말하며 장치마다 다를 수 있다. 초기 네트워크 연결 시 할당된 32비트 고유 시퀀스 번호이다.
1. SYN + ACK(Acknowledgement) 단계
- 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클리이언트의 ISN + 1을 보낸다.
1. ACK 단계
- 클라이언트는 서버의 ISN + 1한 값인 승인번호를 담아 ACK를 서버에 보낸다.

**HTTPS : HTTP 통신하는 소켓 부분을 SSL or TLS 라는 프로토콜로 대체하는 것일 뿐이다. 공개키와 비대칭키로 암호화를 진행한다.**

HTTP의 문제점 : TCP/IP는 도청가능한 네트워크이기 때문에 변조 및 위장이 가능하다.

→ **SSL, TLS 프로토콜** 조합해 HTTP 통신 내용을 암호화 가능.

**TCP와 UDP의 차이**

UDP : 비연결형 프로토콜.

- 3-WAY-HANDSHAKE 하지 않기 때문에 신뢰성이 없다.
- 흐름제어, 손상 제어 또는 손상된 세그먼트 수신에 대한 **재전송 하지 않음.**
- DNS는 UDP를 사용함.

TCP: 신뢰성과 순차적인 전달을 보장.

- 신뢰성이 없는 인터넷을 통해 신뢰성이 있는 바이트 스트림을 전송하도록 특별히 설계됨
- TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다.

**쿠키와 세션의 차이**

- 쿠키와 세션이 나오게 된 배경 : stateless 한 http의 약점을 보완하기 위해서 사용
    - 커넥션 끊는 순간 클라이언트와 서버 통신 끝나고 상태 정보 유지하지 않는 특성이 있다.
    - 데이터 유지가 필요한 경우가 많은데 이때 사용하는 것이 쿠키와 세션이다

**쿠키 : 상태 저장을 로컬 PC에 저장**

- **사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**이다.
- HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 **필요시 정보를 참조하거나 재사용할 수 있다. →** 전혀 서버의 자원 사용하지 않는다. → 보안에 취약
- 특징
1. 이름, 값, 만료일(저장기간), 경로 정보로 구성되어 있다.
2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.

세션 : 서버에 저장 **→ 서버의 자원을 사용한다.** → 비교적 보안성이 높다.

- 특징
1. 웹 서버에 **웹 컨테이너의 상태를 유지하기 위한 정보를 저장**한다.
2. 웹 서버의 저장되는 쿠키(=세션 쿠키)
3. 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다.
4. 저장 데이터에 제한이 없다. (서버 용량이 허용하는 한에서)
5. 각 클라이언트에 고유 Session ID를 부여한다. Session ID로 클라이언트를 구분해 각 요구에 맞는 서비스를 제공

**쿠키와 캐시의 차이**

캐시 : 웹 페이지 요소를 저장하기 위한 임시 저장소

- 캐시는 웹 페이지를 빠르게 렌더링 할 수 있도록 도와주고,

쿠키/세션 : 정보를 저장하기 위해서 사용

- 사용자의 인증을 도와준다.

**OSI 7계층 VS TCP/IP 4 계층**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6192f9c2-64c0-4fad-b508-1d96d7ad3677/Untitled.png)